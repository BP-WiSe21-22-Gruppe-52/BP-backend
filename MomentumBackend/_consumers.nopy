import errno
import json
import os
import time

import socketio
from channels.generic.websocket import WebsocketConsumer

from .Helperclasses.handlers import (ExerciseHandler, LeaderboardHandler,
                                     UserHandler)
from .Helperclasses.jwttoken import JwToken
from .models import (DoneExercises, ExerciseInPlan, Leaderboard, User,
                     UserMedalInExercise)
from .settings import CONFIGURATION


class SetConsumer(WebsocketConsumer):
    def __init__(self):
        super().__init__()

        self.username = None # username of the user is authenticated
        self.exercise = None # exercise that is currently done if initiated

        # self.points = 0
        # # initializing the new connection
        # self.filename = None
        # self.doing_set = False
        # self.username = ""
        # self.user = None

        # self.authenticated = False
        # self.initiated = False

        # # initializing new exercise will be overwritten after init when exercise could be loaded
        # self.executions_per_set = 0
        # self.sets = 0

        # self.exercise = 0
        # self.stats_received = 0
        # self.current_set = 0

        # self.speed = 0
        # self.intensity = 0
        # self.cleanliness = 0

        # self.done_exercise_entry = None
        # self.completed = False

        # self.exinplan = None

        # self.sio = socketio.Client()
        # self.aiCreateEventListener()

        self.repetition_handler_list = []

    # ==================== HELPER FUNCTIONS ====================

    def error_response(self, message_type, description):
        self.send(
            text_data=json.dumps(
                {
                    "message_type": message_type,
                    "success": False,
                    "description": description,
                    "data": {},
                }
            )
        )


    def success_response(self, message_type, description, data={}):
        self.send(
            text_data=json.dumps(
                {
                    "message_type": message_type,
                    "success": True,
                    "description": description,
                    "data": data,
                }
            )
        )


    # in this method the incoming video stream will be saved
    def save_video(self, data_bytes):
        # TODO(WARNING): After this function was initially created the data_bytes was changed to an image and not a video anymore
        # when this should be used again this function has to be changed to create a video from the images and not just save them
        folderName = os.path.join(CONFIGURATION["video_dir"], self.username)
        fileName = os.path.join(
            CONFIGURATION["video_dir"], self.username, self.filename)

        # check if the user folder was already created else mkdir
        if not os.path.exists(folderName):
            try:
                os.mkdir(folderName)
            except OSError as exc:  # Guard against race condition
                if exc.errno != errno.EEXIST:
                    raise

        # add new video blob to the file
        mode = "ab" if os.path.exists(fileName) else "wb"

        with open(fileName, mode) as f:
            f.write(data_bytes)
            f.close()


    def create_repetition_handler(self):
        repetition_handler = socketio.Client()
        repetition_handler.on("information", self.handleAiInformation)
        repetition_handler.on("statistics", self.handleAiStatistics)
        repetition_handler.connect(CONFIGURATION["ai_url"])
        repetition_handler.emit("set_exercise_id", {
                      "exercise": self.exercise.exercise.id})
        return repetition_handler


    # ==================== FRONTEND MESSAGE HANDLERS ====================

    def authenticate(self, session_token):
        # check if token is valid
        token = JwToken.check_session_token(session_token["session_token"])
        if not token["valid"]:
            self.error_response("authenticate", "Token is not valid")
            return

        # check if account_type is user
        if not token["info"]["account_type"] == "user":
            self.error_response("authenticate", "Only users can exercise")
            return

        # set connection as authenticated and connections user info
        self.username = token["info"]["username"]

        self.success_response("authenticate", "User is now authenticated")


    def initiate(self, data):
        # save, which exercise is done
        exercise = data["exercise"]

        # load exercise info from database
        try:
            self.exercise: ExerciseInPlan = ExerciseInPlan.objects.get(
                id=exercise)
        except:
            self.initiated = False
            self.close()
            return
        self.sets = self.exinplan.sets
        self.executions_per_set = self.exinplan.repeats_per_set

        # load already done exercises in this week
        query = DoneExercises.objects.filter(
            date__gt=time.time() - 518400, exercise=self.exercise.exercise.id, user=self.user.id
        )

        # when exercise was already started, load info
        if query.exists():
            self.done_exercise_entry: DoneExercises = query[0]
            self.current_set = self.done_exercise_entry.current_set

            self.speed = self.done_exercise_entry.speed
            self.intensity = self.done_exercise_entry.intensity
            self.cleanliness = self.done_exercise_entry.cleanliness
            self.completed = self.done_exercise_entry.completed

        else:
            # if not started already  initialise
            self.done_exercise_entry = None
            self.current_set = 0
            self.speed = 0
            self.intensity = 0
            self.cleanliness = 0

        # current state of the exercise will be returned
        self.success_response(
            "init",
            "This is the current state",
            {
                "current_set": self.current_set,
                "speed": 0
                if self.stats_received == 0
                else self.speed / self.stats_received,
                "cleanliness": 0
                if self.stats_received == 0
                else self.cleanliness / self.stats_received,
                "intensity": 0
                if self.stats_received == 0
                else self.intensity / self.stats_received,
                "completed": self.completed,
            })


    def start_set(self):
        self.current_repetition_handler = self.create_repetition_handler()
        self.success_response("start_set", "The set is now started")


    def end_repetition(self):
        if self.current_repetition_handler is None:
            self.error_response("end_repetition", "No repetition is active")
            return
        
        # stash repetition handler
        self.repetition_handler_list.append(self.current_repetition_handler)

        # create new repetition handler
        self.current_repetition_handler = self.create_repetition_handler()


    def end_set(self):
        if self.current_repetition_handler is None:
            self.error_response("end_repetition", "No repetition is active")
            return
        
        # stash repetition handler
        self.repetition_handler_list.append(self.current_repetition_handler)

        self.success_response(
            "end_set",
            "The set is now ended", 
            )


    def updateLeaderboard(self):
        leaderboard_entry: Leaderboard = Leaderboard.objects.get(
            user=self.user.id)
        leaderboard_entry.speed += self.speed
        leaderboard_entry.intensity += self.intensity
        leaderboard_entry.cleanliness += self.cleanliness

        exs_to_do = 0
        if self.user.plan is not None:
            plan_data = ExerciseInPlan.objects.filter(plan=self.user.plan.id)
            for ex in plan_data:
                exs_to_do += ex.repeats_per_set * ex.sets

        leaderboard_entry.score = (
            leaderboard_entry.speed
            + leaderboard_entry.intensity
            + leaderboard_entry.cleanliness
        ) / (3 * exs_to_do)

        leaderboard_entry.save(force_update=True)


    def updateMedal(self):
        # add medal
        if not UserMedalInExercise.objects.filter(
            user=self.user, exercise=self.exinplan.exercise
        ).exists():
            UserMedalInExercise.objects.create(
                user=self.user, exercise=self.exinplan.exercise
            )
        umix: UserMedalInExercise = UserMedalInExercise.objects.get(
            user=self.user, exercise=self.exinplan.exercise
        )
        if self.points >= 90:  # gold
            umix.gold += 1
        elif self.points >= 75:  # silver
            umix.silver += 1
        elif self.points >= 50:  # bronze
            umix.bronze += 1
        umix.save(force_update=True)


    def updateXP(self):
        UserHandler.add_xp(
            self.user,
            (
                (self.speed + self.intensity + self.cleanliness)
                / (3 * self.stats_received)
            )
            * (min(self.user.streak, 10) + 1),
        )


    def updateStreak(self):
        # add streak when this was the last exercise today
        user = User.objects.get()
        
        if ExerciseHandler.check_if_last_exercise(self.user):
            self.user.streak += 1
            self.user.save(force_update=True)


    def calculatePoints(self):
        # calculate points
        self.points = (
            0
            if (self.executions_per_set == 0 | self.sets == 0)
            else int(
                (self.speed + self.intensity + self.cleanliness)
                / (self.sets * self.executions_per_set * 3)
            )
        )


    def handleExerciseDone(self):
        # reset current set wrongly incremented
        self.current_set -= 1
        self.completed = True

        self.calculatePoints()

        self.updateMedal()
        self.updateStreak()
        self.updateLeaderboard()
        self.updateXP()

        gained_medal = ""
        if self.points >= 90:  # gold
            gained_medal = "gold"
        elif self.points >= 75:  # silver
            gained_medal = "silver"
        elif self.points >= 50:  # bronze
            gained_medal = "bronze"

        self.success_response(
            "exercise_complete",
            "The exercise is now ended",
            {
                "speed": 0
                if self.stats_received == 0
                else self.speed / self.stats_received,
                "cleanliness": 0
                if self.stats_received == 0
                else self.cleanliness / self.stats_received,
                "intensity": 0
                if self.stats_received == 0
                else self.intensity / self.stats_received,
                "medal": gained_medal,
            })


    # handle incoming stats
    def handleIncomingStats(self, intensity, speed, cleanliness):
        # sanity check
        if not self.doing_set:
            return

        self.stats_received += 1

        # calculating points
        self.intensity += intensity
        self.speed += speed
        self.cleanliness += cleanliness

        self.success_response(
            "statistics",
            "This is the accuracy",
            {
                "intensity": intensity,
                "speed": speed,
                "cleanliness": cleanliness,
            },
        )


    def handleIncomingVideo(self, data):
        # guard to prevent sending video if not doing exercise
        if not self.doing_set:
            self.error_response("", "The set must be started to send the video Stream")
            return

        # self.save_video(data)

        # send video to ai
        self.sio.emit("send_video", data)


    # On Connect
    def connect(self):
        LeaderboardHandler.reset_leaderboard()
        self.filename = None
        self.doing_set = False
        self.accept()


    # On Disconnect
    def disconnect(self, _):
        self.sio.disconnect()
        self.doing_set = False

        # save current state in database
        if self.initiated:
            if self.done_exercise_entry is None:
                DoneExercises.objects.create(
                    exercise=self.exinplan,
                    user=self.user,
                    points=self.points,
                    date=time.time(),
                    current_set=self.current_set,
                    speed=self.speed,
                    intensity=self.intensity,
                    cleanliness=self.cleanliness,
                    completed=self.completed,
                )
            else:
                self.done_exercise_entry.current_set = self.current_set
                self.done_exercise_entry.speed = self.speed
                self.done_exercise_entry.intensity = self.intensity
                self.done_exercise_entry.cleanliness = self.cleanliness
                self.done_exercise_entry.points = self.points
                self.done_exercise_entry.completed = self.completed
                self.done_exercise_entry.save(force_update=True)


    # Momentum Frontend -> Backend
    def receive(self, text_data=None, bytes_data=None):
        # bytes_data is a single frame of the video stream
        # if an image is sent, redirect it to the ai
        if bytes_data is not None:
            self.handleIncomingVideo(bytes_data)

        # guard that check if request hast text_data
        if text_data is None:
            return

        # parse text_data
        text_data_json = json.loads(text_data)
        m_type = text_data_json["message_type"]
        data = text_data_json["data"]

        # check if authenticating
        if m_type == "authenticate":
            self.authenticate(data)
            return

        # guard that check if request has been authenticated
        if not self.authenticated:
            self.error_response("authenticate", "You have to be authenticated")
            return

        # check if initializing
        if m_type == "init":
            self.initiate(data)
            return

        # guard that check if request has been initiated
        if not self.initiated:
            self.error_response("init", "You have to first initialise")
            return

        # guard check if already completed
        if self.completed:
            self.error_response("exercise_complete",
                                "You already completed this Exercise")
            return

        # start the set
        if m_type == "start_set":
            self.start_set()
            return

        # end one repetition
        if m_type == "end_repetition":
            self.end_repetition(data)
            return

        # end the set
        if m_type == "end_set":
            pass
            self.end_set()
